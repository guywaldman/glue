use crate::codegen::{CodeGen, CodeGenError};
use gluelang::Program;

pub struct TypeScriptZodCodeGen;

impl TypeScriptZodCodeGen {
    pub fn new() -> Self {
        TypeScriptZodCodeGen
    }
}

impl CodeGen for TypeScriptZodCodeGen {
    fn generate(&self, program: &Program) -> Result<String, CodeGenError> {
        let mut output = String::new();

        output.push_str("// This file is autogenerated by gluegen. Do not edit.\n");
        output.push_str("// eslint-disable\n// tslint:disable\n// @ts-nocheck\n\n");

        output.push_str("import { z } from 'zod';\n\n");

        let models = program.models();
        let enums = program.enums();

        // TODO: Organize nested models next to their parents

        for en in &enums {
            if let Some(doc) = &en.doc {
                output.push_str("  ");
                output.push_str(generate_doc(doc)?.as_str());
            }
            output.push_str(&format!("const z{} = z.enum([\n", en.effective_name()));
            for value in &en.variants {
                output.push_str(&format!("  \"{value}\",\n"));
            }
            output.push_str("]);\n");
            output.push_str(&format!(
                "type {} = z.infer<typeof z{}>;\n\n",
                en.effective_name(),
                en.effective_name()
            ));
            output.push('\n');
        }

        for model in &models {
            if let Some(doc) = &model.doc {
                output.push_str("  ");
                output.push_str(generate_doc(doc)?.as_str());
            }
            output.push_str(&format!("const z{} = z.object({{\n", model.effective_name()));
            for field in &model.fields {
                let mut ty_strings = Vec::new();
                for atom in &field.ty.atoms {
                    let mut ty_str = match atom.name.as_str() {
                        "string" => "z.string()".to_string(),
                        "int" => "z.number()".to_string(),
                        "bool" => "z.boolean()".to_string(),
                        other => {
                            if atom.is_ref {
                                if let Some(model) = models.iter().find(|m| m.name == other) {
                                    // Check refs
                                    format!("z{}", model.effective_name())
                                } else if let Some(en) = enums.iter().find(|e| e.name == other) {
                                    format!("z{}", en.effective_name())
                                } else {
                                    return Err(CodeGenError::UnsupportedError(format!(
                                        "Zod codegen does not support type: {other}"
                                    )));
                                }
                            } else {
                                return Err(CodeGenError::UnsupportedError(format!(
                                    "Zod codegen does not support type: {other}"
                                )));
                            }
                        }
                    };
                    if atom.is_array {
                        ty_str.push_str(".array()");
                    }
                    if atom.is_optional {
                        ty_str.push_str(".optional()");
                    }
                    ty_strings.push(ty_str);
                }

                if let Some(doc) = &field.doc {
                    output.push_str("  ");
                    output.push_str(generate_doc(doc)?.as_str());
                }
                let type_expression = if ty_strings.len() == 1 {
                    ty_strings[0].clone()
                } else {
                    ty_strings.join(".or(") + ")"
                };
                output.push_str(&format!("  {}: {}", field.name, type_expression));
                // TODO: Support alias in Zod (https://github.com/colinhacks/zod/discussions/1143#discussioncomment-4314155)
                output.push_str(",\n");
            }
            output.push_str("});\n");

            output.push_str(&format!(
                "type {} = z.infer<typeof z{}>;\n\n",
                model.effective_name(),
                model.effective_name()
            ));
            output.push('\n');
        }
        Ok(output)
    }
}

fn generate_doc(doc: &str) -> Result<String, CodeGenError> {
    let lines_count = doc.lines().count();
    let mut output = String::with_capacity(doc.len() + lines_count * 5);
    if lines_count == 1 {
        output.push_str(&format!("/** {doc} */\n"));
    } else {
        output.push_str("/**\n");
        for line in doc.lines() {
            output.push_str(&format!(" * {line}\n"));
        }
        output.push_str(" */\n");
    }
    Ok(output)
}
