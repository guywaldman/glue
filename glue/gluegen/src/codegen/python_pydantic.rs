use crate::codegen::{CodeGen, CodeGenError};
use gluelang::Program;

pub struct PythonPydanticCodeGen;

impl PythonPydanticCodeGen {
    pub fn new() -> Self {
        PythonPydanticCodeGen
    }
}

impl CodeGen for PythonPydanticCodeGen {
    fn generate(&self, program: &Program) -> Result<String, CodeGenError> {
        let mut output = String::new();

        output.push_str("# This file is autogenerated by gluegen. Do not edit.\n");
        output.push_str("from pydantic import BaseModel, Field\n\n");
        output.push_str("from typing import Optional, Annotated\n\n");

        for model in &program.models {
            output.push_str(&format!("class {}(BaseModel):\n", model.effective_name()));
            if let Some(doc) = &model.doc {
                output.push_str(generate_doc(doc)?.as_str());
            }
            for field in &model.fields {
                let mut ty_strings = Vec::new();
                for atom in &field.ty.atoms {
                    let ty_str = match atom.name.as_str() {
                        "string" => "str".to_string(),
                        "int" => "int".to_string(),
                        "bool" => "bool".to_string(),
                        other => {
                            if atom.is_ref {
                                if let Some(model) = program.models.iter().find(|m| m.name == other) {
                                    // Check refs
                                    model.effective_name()
                                } else {
                                    return Err(CodeGenError::UnresolvedReference(other.to_string()));
                                }
                            } else {
                                return Err(CodeGenError::UnsupportedError(format!(
                                    "Zod codegen does not support type: {other}"
                                )));
                            }
                        }
                    };
                    if atom.optional {
                        ty_strings.push(format!("Optional[{ty_str}]"));
                    } else {
                        ty_strings.push(ty_str);
                    }
                }

                let type_expression = if ty_strings.len() == 1 {
                    ty_strings[0].clone()
                } else {
                    ty_strings.join(" | ")
                };

                let mut field_params = Vec::new();
                // TODO: Union with one of them optional?
                if field.ty.atoms.iter().any(|atom| atom.optional) {
                    field_params.push("default=None".to_string());
                }
                if let Some(annotation) = &field.annotation {
                    if let Some(alias_arg) = annotation.named_args.iter().find(|(name, _)| name == "alias") {
                        let alias_str = format!("alias=\"{}\"", alias_arg.1);
                        field_params.push(alias_str);
                    }
                }
                let field_params_str = field_params.join(", ");

                output.push_str(&format!(
                    "    {}: Annotated[{}, Field({})]\n",
                    field.name, type_expression, field_params_str
                ));
                if let Some(doc) = &field.doc {
                    output.push_str(generate_doc(doc)?.as_str());
                }
            }
            output.push_str("\n\n");
        }
        Ok(output)
    }
}

fn generate_doc(doc: &str) -> Result<String, CodeGenError> {
    let mut output = String::new();
    if doc.lines().count() == 1 {
        output.push_str(&format!("    \"\"\"{}\"\"\"\n", doc.trim()));
        return Ok(output);
    }
    output.push_str("    \"\"\"\n");
    for line in doc.lines() {
        output.push_str("    ");
        output.push_str(line);
        output.push('\n');
    }
    output.push_str("    \"\"\"\n");
    Ok(output)
}
