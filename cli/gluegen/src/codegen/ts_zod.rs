use crate::codegen::{CodeGen, CodeGenError};
use gluelang::Program;

pub struct TypeScriptZodCodeGen;

impl TypeScriptZodCodeGen {
    pub fn new() -> Self {
        TypeScriptZodCodeGen
    }
}

impl CodeGen for TypeScriptZodCodeGen {
    fn generate(&self, program: &Program) -> Result<String, CodeGenError> {
        let mut output = String::new();

        output.push_str("// This file is autogenerated by gluegen. Do not edit.\n");
        output.push_str("// eslint-disable\n// tslint:disable\n// @ts-nocheck\n\n");

        output.push_str("import { z } from 'zod';\n\n");

        for model in &program.models {
            if let Some(doc) = &model.doc {
                output.push_str("  ");
                output.push_str(self.generate_doc(doc)?.as_str());
            }
            output.push_str(&format!("const {} = z.object({{\n", model.name));
            for field in &model.fields {
                let mut ty_strings = Vec::new();
                for atom in &field.ty.atoms {
                    let ty_str = match atom.name.as_str() {
                        "string" => "z.string()".to_string(),
                        "int" => "z.number()".to_string(),
                        "bool" => "z.boolean()".to_string(),
                        other => {
                            if atom.is_ref {
                                if program.models.iter().any(|m| m.name == other) {
                                    // Check refs
                                    other.to_string()
                                } else {
                                    return Err(CodeGenError::UnresolvedReference(
                                        other.to_string(),
                                    ));
                                }
                            } else {
                                return Err(CodeGenError::UnsupportedError(format!(
                                    "Zod codegen does not support type: {other}"
                                )));
                            }
                        }
                    };
                    ty_strings.push(ty_str);
                }

                if let Some(doc) = &field.doc {
                    output.push_str("  ");
                    output.push_str(self.generate_doc(doc)?.as_str());
                }
                let type_expression = if ty_strings.len() == 1 {
                    ty_strings[0].clone()
                } else {
                    ty_strings.join(".or(") + ")"
                };
                output.push_str(&format!("  {}: {}", field.name, type_expression));
                if let Some(doc) = &field.doc {
                    output.push_str(format!(r#".meta( {{ "description": `{doc}` }})"#).as_str());
                }
                // TODO: Support alias in Zod (https://github.com/colinhacks/zod/discussions/1143#discussioncomment-4314155)
                output.push_str(",\n");
            }
            output.push_str("});\n\n");
        }
        Ok(output)
    }
}

// Helper method
impl TypeScriptZodCodeGen {
    fn generate_doc(&self, doc: &str) -> Result<String, CodeGenError> {
        let lines_count = doc.lines().count();
        let mut output = String::with_capacity(doc.len() + lines_count * 5);
        if lines_count == 1 {
            output.push_str(&format!("/** {doc} */\n"));
        } else {
            output.push_str("/**\n");
            for line in doc.lines() {
                output.push_str(&format!(" * {line}\n"));
            }
            output.push_str(" */\n");
        }
        Ok(output)
    }
}
