use crate::codegen::{CodeGen, CodeGenError};
use gluelang::Program;

pub struct TypeScriptZodCodeGen;

impl TypeScriptZodCodeGen {
    pub fn new() -> Self {
        TypeScriptZodCodeGen
    }
}

impl CodeGen for TypeScriptZodCodeGen {
    fn generate(&self, program: &Program) -> Result<String, CodeGenError> {
        let mut output = String::new();

        output.push_str("// This file is autogenerated by gluegen. Do not edit.\n");
        output.push_str("// eslint-disable\n// tslint:disable\n// @ts-nocheck\n\n");

        output.push_str("import { z } from 'zod';\n\n");

        for model in &program.models {
            if let Some(doc) = &model.doc {
                output.push_str("  ");
                output.push_str(generate_doc(doc)?.as_str());
            }
            output.push_str(&format!("const {} = z.object({{\n", model.effective_name()));
            for field in &model.fields {
                let mut ty_strings = Vec::new();
                for atom in &field.ty.atoms {
                    let ty_str = match atom.name.as_str() {
                        "string" => "z.string()".to_string(),
                        "int" => "z.number()".to_string(),
                        "bool" => "z.boolean()".to_string(),
                        other => {
                            if atom.is_ref {
                                if let Some(model) = program.models.iter().find(|m| m.name == other) {
                                    // Check refs
                                    model.effective_name()
                                } else {
                                    return Err(CodeGenError::UnresolvedReference(other.to_string()));
                                }
                            } else {
                                return Err(CodeGenError::UnsupportedError(format!(
                                    "Zod codegen does not support type: {other}"
                                )));
                            }
                        }
                    };
                    ty_strings.push(ty_str);
                }

                if let Some(doc) = &field.doc {
                    output.push_str("  ");
                    output.push_str(generate_doc(doc)?.as_str());
                }
                let type_expression = if ty_strings.len() == 1 {
                    ty_strings[0].clone()
                } else {
                    ty_strings.join(".or(") + ")"
                };
                output.push_str(&format!("  {}: {}", field.name, type_expression));
                // TODO: Add descriptions to Zod - `.meta({ description: "..." })`. Trouble is newlines.
                // TODO: Support alias in Zod (https://github.com/colinhacks/zod/discussions/1143#discussioncomment-4314155)
                output.push_str(",\n");
            }
            output.push_str("});\n\n");
        }
        Ok(output)
    }
}

fn generate_doc(doc: &str) -> Result<String, CodeGenError> {
    let lines_count = doc.lines().count();
    let mut output = String::with_capacity(doc.len() + lines_count * 5);
    if lines_count == 1 {
        output.push_str(&format!("/** {doc} */\n"));
    } else {
        output.push_str("/**\n");
        for line in doc.lines() {
            output.push_str(&format!(" * {line}\n"));
        }
        output.push_str(" */\n");
    }
    Ok(output)
}
